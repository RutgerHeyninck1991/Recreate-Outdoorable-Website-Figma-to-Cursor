import React, { useState, useEffect } from 'react';import { useNavigate } from 'react-router-dom';import { Button } from './ui/button';import { Card } from './ui/card';import { Badge } from './ui/badge';import { Loader2, Upload, Check, AlertCircle, Database, FolderSync, Home, ArrowLeft } from 'lucide-react';import { fabricApi, type Fabric } from '../utils/fabricApi';// Import the texture assetsimport navyTexture from '../assets/d060cedf1f9e6e71552bb7006a3e9151e72785cf.png';import beigeTexture from '../assets/49d34b83767a7492092a366ef5a56fb03a94312c.png';import creamTexture from '../assets/8c8342c3728186a94fc53915609c8a17d13b8fa2.png';interface TextureMapping {  fabricId: string;  texturePath: string;  name: string;  color: string;  description: string;}const TEXTURE_MAPPINGS: TextureMapping[] = [  {    fabricId: 'premium-sunbrella-navy',    texturePath: navyTexture,    name: 'Sunbrella Marine Navy',    color: '#1F2937',    description: 'Premium Sunbrella stof in navy blauw met spikkel textuur'  },  {    fabricId: 'outdoor-canvas-sand',    texturePath: beigeTexture,    name: 'Outdoor Canvas Zand',    color: '#D4B896',    description: 'Natuurlijke zandkleur met warme gemeleerde textuur'  },  {    fabricId: 'outdoor-canvas-cream',    texturePath: creamTexture,    name: 'Outdoor Canvas Cr√®me',    color: '#F5F1EA',    description: 'Lichte cr√®me kleur met subtiele gemeleerde textuur'  }];interface FabricManagerProps {  onNavigateHome?: () => void;}const FabricManager: React.FC<FabricManagerProps> = ({ onNavigateHome }) => {  const navigate = useNavigate();  const [isUpdating, setIsUpdating] = useState(false);  const [updateStatus, setUpdateStatus] = useState<{[key: string]: 'pending' | 'success' | 'error'}>({});  const [fabrics, setFabrics] = useState<Fabric[]>([]);  const [isSyncing, setIsSyncing] = useState(false);  const [syncMessage, setSyncMessage] = useState<string>('');  const [storageBuckets, setStorageBuckets] = useState<any[]>([]);  const [selectedBucket, setSelectedBucket] = useState<string>('');  const [bucketFiles, setBucketFiles] = useState<any[]>([]);  useEffect(() => {    loadFabrics();    loadStorageBuckets();  }, []);  const loadFabrics = async () => {    try {      const allFabrics = await fabricApi.getFabrics();      setFabrics(allFabrics);    } catch (error) {      console.error('Failed to load fabrics:', error);    }  };  const loadStorageBuckets = async () => {    try {      const buckets = await fabricApi.getStorageBuckets();      setStorageBuckets(buckets);      console.log('Available storage buckets:', buckets);            // Auto-select first bucket that contains "sunproof" in the name      const sunproofBucket = buckets.find((b: any) =>         b.name?.toLowerCase().includes('sunproof')      );      if (sunproofBucket) {        setSelectedBucket(sunproofBucket.name);        loadBucketFiles(sunproofBucket.name);      }    } catch (error) {      console.error('Failed to load storage buckets:', error);    }  };  const loadBucketFiles = async (bucketName: string) => {    try {      const files = await fabricApi.getStorageFiles(bucketName);      setBucketFiles(files);      console.log(`Files in bucket "${bucketName}":`, files);    } catch (error) {      console.error(`Failed to load files from bucket "${bucketName}":`, error);      setBucketFiles([]);    }  };  const syncFromStorage = async (bucketName?: string) => {    setIsSyncing(true);    setSyncMessage('');    try {      const result = await fabricApi.syncFromStorage(bucketName);            // Show detailed sync information      let message = `‚úì Synchronisatie voltooid!`;            if (result.totalFilesInBucket !== undefined) {        message += `üìÅ Totaal bestanden in bucket: ${result.totalFilesInBucket}`;      }            if (result.count !== undefined) {        message += `‚úÖ Gesynchroniseerd: ${result.count} stoffen`;      }            if (result.created !== undefined) {        message += `üÜï Nieuw toegevoegd: ${result.created}`;      }            if (result.updated !== undefined) {        message += `üîÑ Bijgewerkt: ${result.updated}`;      }            if (result.skipped !== undefined && result.skipped > 0) {        message += `‚è≠Ô∏è Overgeslagen (geen afbeeldingen): ${result.skipped}`;      }            if (result.bucket) {        message += `üì¶ Bucket: "${result.bucket}"`;      }            if (result.processedFiles && result.processedFiles.length > 0) {        message += `üìã Verwerkte bestanden:${result.processedFiles.slice(0, 20).join(', ')}`;        if (result.processedFiles.length > 20) {          message += `... en ${result.processedFiles.length - 20} meer`;        }      }            setSyncMessage(message);            // Reload fabrics and buckets after sync      setTimeout(() => {        loadFabrics();        loadStorageBuckets();      }, 1000);    } catch (error: any) {      // Try to parse error response for more details      let errorMessage = 'Onbekende fout';            if (error instanceof Error) {        errorMessage = error.message;                // Check if the error message contains JSON with more details        try {          const jsonMatch = error.message.match(/\{.*\}/);          if (jsonMatch) {            const errorData = JSON.parse(jsonMatch[0]);            if (errorData.message) {              errorMessage = errorData.message;            }            if (errorData.availableBuckets && errorData.availableBuckets.length > 0) {              errorMessage += `Beschikbare buckets: ${errorData.availableBuckets.join(', ')}`;            }          }        } catch (parseError) {          // Keep original error message        }      }            setSyncMessage(`‚úó Fout bij synchroniseren:${errorMessage}`);      console.error('Sync error:', error);    } finally {      setIsSyncing(false);    }  };  const updateFabricWithTexture = async (mapping: TextureMapping) => {    try {      setUpdateStatus(prev => ({ ...prev, [mapping.fabricId]: 'pending' }));            // Check if fabric exists, if not create it      let fabric: Fabric;      try {        fabric = await fabricApi.getFabric(mapping.fabricId);      } catch (error) {        // Fabric doesn't exist, create it        const newFabric = {          id: mapping.fabricId,          name: mapping.name,          category: mapping.fabricId.includes('premium') ? 'premium' : 'outdoor',          color: mapping.color,          textureUrl: mapping.texturePath,          description: mapping.description,          pricePerMeter: mapping.fabricId.includes('premium') ? 65 : 35,          composition: mapping.fabricId.includes('premium') ? '100% Sunbrella Acryl' : '100% Polyester',          waterResistant: true,          uvResistant: true,          active: true,          order: mapping.fabricId.includes('premium') ? 20 : 5,          tags: mapping.fabricId.includes('premium') ?             ['premium', 'sunbrella', 'marine', 'texture'] :             ['premium', 'outdoor', 'waterproof', 'texture']        };                fabric = await fabricApi.createFabric(newFabric);        setUpdateStatus(prev => ({ ...prev, [mapping.fabricId]: 'success' }));        return;      }      // Update existing fabric with texture      const updatedFabric = await fabricApi.updateFabric(mapping.fabricId, {        textureUrl: mapping.texturePath,        color: mapping.color,        name: mapping.name,        description: mapping.description,        tags: [...(fabric.tags || []), 'texture'].filter((tag, index, arr) => arr.indexOf(tag) === index)      });      setUpdateStatus(prev => ({ ...prev, [mapping.fabricId]: 'success' }));    } catch (error) {      console.error(`Failed to update fabric ${mapping.fabricId}:`, error);      setUpdateStatus(prev => ({ ...prev, [mapping.fabricId]: 'error' }));    }  };  const updateAllTextures = async () => {    setIsUpdating(true);    setUpdateStatus({});    // Initialize fabrics first    try {      await fabricApi.initializeFabrics();    } catch (error) {      console.log('Fabrics already initialized or error:', error);    }    // Update each fabric with its texture    for (const mapping of TEXTURE_MAPPINGS) {      await updateFabricWithTexture(mapping);    }    setIsUpdating(false);        // Reload fabrics to show updated data    setTimeout(() => {      loadFabrics();    }, 1000);  };  const getStatusIcon = (fabricId: string) => {    const status = updateStatus[fabricId];    switch (status) {      case 'pending':        return <Loader2 className="w-4 h-4 animate-spin text-blue-600" />;      case 'success':        return <Check className="w-4 h-4 text-green-600" />;      case 'error':        return <AlertCircle className="w-4 h-4 text-red-600" />;      default:        return null;    }  };  return (    <div className="p-6 max-w-6xl mx-auto">      <div className="mb-8">        <div className="flex items-center gap-4 mb-6">          <Button             onClick={() => onNavigateHome ? onNavigateHome() : navigate('/')}            variant="outline"            className="border-stone-300 text-stone-700 hover:bg-stone-50"          >            <ArrowLeft className="w-4 h-4 mr-2" />            Terug naar Homepage          </Button>        </div>                <h1 className="text-3xl font-medium text-stone-800 mb-4">          Fabric Texturen Integratie        </h1>        <p className="text-stone-600 mb-6">          Integreer fabric texturen in het configurator systeem vanuit lokale assets of Supabase Storage.        </p>                <div className="flex gap-4 flex-wrap">          <Button             onClick={updateAllTextures}            disabled={isUpdating}            className="bg-stone-800 hover:bg-stone-900 text-white"          >            {isUpdating ? (              <>                <Loader2 className="w-4 h-4 mr-2 animate-spin" />              Texturen Toevoegen...            </>          ) : (            <>              <Upload className="w-4 h-4 mr-2" />              Voeg Lokale Texturen Toe            </>          )}        </Button>        <Button           onClick={syncFromStorage}          disabled={isSyncing}          className="bg-blue-600 hover:bg-blue-700 text-white"        >          {isSyncing ? (            <>              <Loader2 className="w-4 h-4 mr-2 animate-spin" />              Synchroniseren...            </>          ) : (            <>              <FolderSync className="w-4 h-4 mr-2" />              Sync vanuit Storage            </>          )}        </Button>        <Button           onClick={() => {            fabricApi.initializeFabrics().then(() => {              setSyncMessage('‚úì Default fabrics ge√Ønitialiseerd');              setTimeout(() => loadFabrics(), 1000);            }).catch(err => {              setSyncMessage(`‚úó Fout: ${err.message}`);            });          }}          variant="outline"          className="border-stone-300"        >          <Database className="w-4 h-4 mr-2" />          Init Default Fabrics        </Button>        <Button           onClick={async () => {            if (!confirm('Weet je zeker dat je alle default (outdoor/indoor/premium) fabrics wilt verwijderen? Alleen Sunproof stoffen blijven over.')) {              return;            }                        try {              const result = await fabricApi.cleanupDefaultFabrics();              setSyncMessage(`‚úì ${result.message}Verwijderd: ${result.deleted} fabricsOvergebleven: ${result.remaining} fabrics`);              setTimeout(() => loadFabrics(), 1000);            } catch (err: any) {              setSyncMessage(`‚úó Fout bij opruimen: ${err.message}`);            }          }}          variant="outline"          className="border-red-300 text-red-700 hover:bg-red-50"        >          <AlertCircle className="w-4 h-4 mr-2" />          Verwijder Default Fabrics        </Button>      </div>      {syncMessage && (        <div className={`mb-6 p-4 rounded-lg ${          syncMessage.startsWith('‚úì') ? 'bg-green-50 text-green-800 border border-green-200' :           'bg-red-50 text-red-800 border border-red-200'        }`}>          <pre className="whitespace-pre-wrap font-sans text-sm">{syncMessage}</pre>        </div>      )}      {storageBuckets.length === 0 && (        <div className="mb-6 p-4 bg-amber-50 rounded-lg border border-amber-200">          <h3 className="font-medium text-amber-800 mb-2">‚ö†Ô∏è Geen Storage Buckets Gevonden</h3>          <p className="text-sm text-amber-700 mb-2">            Er zijn geen storage buckets gevonden in je Supabase project.          </p>          <p className="text-sm text-amber-700">            <strong>Stappen om een bucket aan te maken:</strong>          </p>          <ol className="text-sm text-amber-700 list-decimal list-inside ml-2 mt-1">            <li>Ga naar je Supabase Dashboard</li>            <li>Klik op "Storage" in het menu</li>            <li>Klik op "Create a new bucket"</li>            <li>Noem de bucket "SUNPROOF SELECTIE"</li>            <li>Maak de bucket Public (belangrijk!)</li>            <li>Upload je stof afbeeldingen naar deze bucket</li>            <li>Kom terug naar deze pagina en klik op "Sync vanuit Storage"</li>          </ol>        </div>      )}      {storageBuckets.length > 0 && (        <div className="mb-6 p-4 bg-stone-50 rounded-lg border border-stone-200">          <h3 className="font-medium text-stone-800 mb-3">Beschikbare Storage Buckets ({storageBuckets.length}):</h3>          <div className="flex flex-wrap gap-2 mb-4">            {storageBuckets.map((bucket) => (              <button                key={bucket.id || bucket.name}                onClick={() => {                  setSelectedBucket(bucket.name);                  loadBucketFiles(bucket.name);                }}                className={`px-3 py-1 rounded-lg text-sm transition-colors ${                  selectedBucket === bucket.name                    ? 'bg-stone-800 text-white'                    : 'bg-white text-stone-700 border border-stone-300 hover:bg-stone-100'                }`}              >                {bucket.name}              </button>            ))}          </div>                    {selectedBucket && (            <div className="mt-4 pt-4 border-t border-stone-300">              <div className="flex items-center justify-between mb-3">                <h4 className="text-sm font-medium text-stone-700">                  Bucket: "{selectedBucket}"                </h4>                <Button                   onClick={() => syncFromStorage(selectedBucket)}                  disabled={isSyncing}                  size="sm"                  className="bg-blue-600 hover:bg-blue-700 text-white"                >                  {isSyncing ? (                    <>                      <Loader2 className="w-3 h-3 mr-1 animate-spin" />                      Syncing...                    </>                  ) : (                    <>                      <FolderSync className="w-3 h-3 mr-1" />                      Sync deze bucket                    </>                  )}                </Button>              </div>                            {bucketFiles.length > 0 && (                <>                  <p className="text-xs text-stone-600 mb-2">                    {bucketFiles.length} bestanden gevonden                  </p>                  <div className="grid grid-cols-2 md:grid-cols-4 gap-2 max-h-40 overflow-y-auto">                    {bucketFiles.map((file, index) => (                      <div key={index} className="text-xs text-stone-600 bg-white p-2 rounded border border-stone-200 truncate" title={file.name}>                        {file.name}                      </div>                    ))}                  </div>                </>              )}                            {bucketFiles.length === 0 && (                <div className="text-sm text-stone-600">                  Geen bestanden gevonden of bezig met laden...                </div>              )}            </div>          )}        </div>      )}      </div>      <div className="grid md:grid-cols-3 gap-6 mb-8">        {TEXTURE_MAPPINGS.map((mapping) => (          <Card key={mapping.fabricId} className="p-4">            <div className="mb-4">              <div                 className="w-full h-32 rounded-lg mb-3"                style={{                   backgroundColor: mapping.color,                  backgroundImage: `url(${mapping.texturePath})`,                  backgroundSize: 'cover',                  backgroundPosition: 'center',                  backgroundBlendMode: 'overlay'                }}              />              <div className="flex items-center justify-between mb-2">                <h3 className="font-medium text-stone-800">{mapping.name}</h3>                {getStatusIcon(mapping.fabricId)}              </div>              <p className="text-sm text-stone-600 mb-3">                {mapping.description}              </p>              <div className="flex items-center space-x-2">                <Badge variant="outline" className="text-xs">                  {mapping.fabricId}                </Badge>                <div                   className="w-4 h-4 rounded border"                  style={{ backgroundColor: mapping.color }}                />              </div>            </div>                        <Button              onClick={() => updateFabricWithTexture(mapping)}              disabled={isUpdating || updateStatus[mapping.fabricId] === 'pending'}              variant="outline"              size="sm"              className="w-full"            >              {updateStatus[mapping.fabricId] === 'pending' ? (                <Loader2 className="w-4 h-4 mr-2 animate-spin" />              ) : updateStatus[mapping.fabricId] === 'success' ? (                <Check className="w-4 h-4 mr-2" />              ) : (                <Upload className="w-4 h-4 mr-2" />              )}              {updateStatus[mapping.fabricId] === 'success' ? 'Toegevoegd' : 'Voeg Toe'}            </Button>          </Card>        ))}      </div>      {fabrics.length > 0 && (        <div>          <h2 className="text-xl font-medium text-stone-800 mb-4">            Huidige Fabrics in Database ({fabrics.length})          </h2>          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">            {fabrics.map((fabric) => (              <Card key={fabric.id} className="p-3">                <div className="flex items-center space-x-3">                  <div                     className="w-12 h-12 rounded border flex-shrink-0"                    style={{                       backgroundColor: fabric.color,                      backgroundImage: fabric.textureUrl ? `url(${fabric.textureUrl})` : undefined,                      backgroundSize: 'cover',                      backgroundPosition: 'center',                      backgroundBlendMode: fabric.textureUrl ? 'overlay' : 'normal'                    }}                  />                  <div className="flex-1 min-w-0">                    <h3 className="font-medium text-sm text-stone-800 truncate">                      {fabric.name}                    </h3>                    <p className="text-xs text-stone-600 capitalize">                      {fabric.category}                    </p>                    <div className="flex items-center space-x-1 mt-1">                      {fabric.textureUrl && (                        <Badge variant="secondary" className="text-xs bg-green-100 text-green-700">                          Textuur                        </Badge>                      )}                      <Badge variant="outline" className="text-xs">                        ‚Ç¨{fabric.pricePerMeter}                      </Badge>                    </div>                  </div>                </div>              </Card>            ))}          </div>        </div>      )}    </div>  );};export default FabricManager;
